# 网络编程

网络拥塞、丢包、重发、网络抖动、流量控制、网络风暴

只要有等待的地方都可能出现DDoS攻击。







## Binary vs Text

区别在于协议是面向数据结构还是面向文本的。比如，HTTP协议也可以传输图片，并且是直接传输的二进制字节流，但依然是文本协议。[参考链接](https://stackoverflow.com/a/2645168)

Binary协议的例子： [RTP](http://tools.ietf.org/html/rfc3550), [TCP](http://tools.ietf.org/html/rfc793), [IP](http://tools.ietf.org/html/rfc791)。

Text协议的例子：[SMTP](http://tools.ietf.org/html/rfc5321), [HTTP](http://tools.ietf.org/html/rfc2616), [SIP](http://tools.ietf.org/html/rfc3261)。

Binary协议的主要优点：

1. 更紧凑
2. 易于解析

Text协议的优点：

1. 易于调试
2. 易于理解



## HTTP

### 模式演进

#### HTTP/1.0

建立TCP连接-客户端发送请求-服务器端回复响应-断开连接

#### HTTP/1.1和部分HTTP/1.0

支持持久连接（keep-alive）。只要任意一端没有明确提出断开连接，则保持TCP连接状态。通过一个TCP连接，可以进行多次请求和响应的交互。

HTTP/1.1中，所有的连接默认都是持久连接。

在一个连接上，不能同时发送多个请求。发送请求后需等待并接收到响应，才能发送下一个请求。

#### HTTP/1.1

管线化（pipeline）：可以顺序发送多个请求，服务器顺序响应多个请求。

#### HTTP/2.0

多路复用：在一条连接上可以同时发送多个请求和响应。一条物理连接会虚拟为多条逻辑连接，并支持优先级。

由于TCP的固有特性，依然存在队头阻塞问题。

[网络编程懒人入门(七)：深入浅出，全面理解HTTP协议](http://www.52im.net/thread-1677-1-1.html)

## HTTPS

HTTPS = HTTP + SSL/TLS。

*解决了什么问题？*

- 主机（服务器）信任问题

  服务器必须从CA申请一个证明其用途类型的证书，该证书只有用于对应的服务器的时候，客户端才信任该服务器。

  在安全非常敏感的领域，如银行专业版客户端，会要求客户端也有一个证书，具体证书可能是拿U盘（即U盾）作为一个备份的载体

- 通讯过程中数据泄露和被篡改的问题

加密和身份验证。

端口：443。

*如何保证通信的安全性呢？*

加密。

*用什么加密方式呢？*

同步加密怎么样？

*不行，密钥肯定不能公开呀*



*为什么一定要有CA呢？*

无论是对称加密还是非对称加密，无论加密几层，最外层总是要明文的，但是为了保证安全又不能明文。那怎么办呢？通过第三方权威机构，所有通讯设备提前存储权威机构的公钥，用权威机构的私钥加密自己的密钥。

![TLS/SSL](https://blog-image-1252287090.cos.ap-beijing.myqcloud.com/TLS_SSL.jpeg)

一次完全TLS握手，密钥交换时的非对称解密计算量占整个握手过程的90%以上。而对称加密的计算量只相当于非对称加密的0.1%。加解密同等数量的文件，非对称算法消耗的CPU资源是对称算法的1000倍以上。

#### **非对称加解密（极端消耗CPU资源）目前只能用来作对称密钥交换或者CA签名，不适合用来做应用层内容传输的加解密。**

## HTTP/2

### HTTP/2.0还是HTTP2?

由于HTTP/1.x导致了很多混乱，所以工作组决定去除小版本。

[is-it-http20-or-http2](https://http2.github.io/faq/#is-it-http20-or-http2)

### 与HTTP/1.x的主要差别？

从高层次来说，HTTP/2：

- 是二进制的，而不是文本的
- 是完全多路复用的，而不是有序和阻塞的
- 可以用一个连接实现并行性
- 使用头部压缩来减少开销
- 允许服务器主动地“推送”响应到客户端缓存

### 为什么是二进制的？

二进制协议解析更高效，“在线上”更紧凑，最重要的是，相对于HTTP/1.x这样的文本协议来说，更加不容易出错。

### 如何发送HTTP/2请求？

由于客户端不知道服务器是否支持HTTP/2，所以肯定不能直接发送HTTP/2格式的请求。那怎么办呢？“Upgrade”头字段就是用来解决这个问题的。

“Upgrade”头字段提供了一个简单的机制，用于在同一连接上从HTTP/1.1转换为其它协议。“Upgrade”字段是一个协议列表，告知服务器可以切换到这些协议，按降序排列。服务器可以忽略该字段。

```
GET /hello.txt HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: HTTP/2.0
```

### 参考资源

- [HTTP/2](https://blog.fe.ioteams.com/post/http2.html#toc-165)
- [HTTP/2 Frequently Asked Questions](https://http2.github.io/faq/)
- 

## 知识点

### HTTP常见状态码

<center>HTTP状态码分类</center>

| 分类 | 分类描述                                       |
| ---- | ---------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

<center>HTTP状态码列表</center>

| 状态码 | 状态码英文名称                  | 中文描述                                                     |
| ------ | ------------------------------- | ------------------------------------------------------------ |
| 100    | Continue                        | 继续。[客户端](http://www.dreamdu.com/webbuild/client_vs_server/)应继续其请求 |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|        |                                 |                                                              |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|        |                                 |                                                              |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

## OSI与TCP/IP

| OSI中的层  | 功能                                   | TCP/IP协议族                             |
| ---------- | -------------------------------------- | ---------------------------------------- |
| 应用层     | 文件传输，电子邮件，文件服务，虚拟终端 | TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet |
| 表示层     | 数据格式化，代码转换，数据加密         | 没有协议                                 |
| 会话层     | 解除或建立与别的接点的联系             | 没有协议                                 |
| 传输层     | 提供端对端的接口                       | TCP，UDP                                 |
| 网络层     | 为数据包选择路由                       | IP，ICMP，RIP，OSPF，BGP，IGMP           |
| 数据链路层 | 传输有地址的帧以及错误检测功能         | SLIP，CSLIP，PPP，ARP，RARP，MTU         |
| 物理层     | 以二进制数据形式在物理媒体上传输数据   | ISO2110，IEEE802，IEEE802.2              |



- 以太网最大Frame数据大小为1500字节（即MTU，Maximum Transmission Unit），IP数据报文包头最小20字节，TCP Segment包头最小20字节，IP和TCP包头各有40字节的可选项。

- 一个标准的以太网数据帧大小是：`1518`，头信息有14字节，尾部校验和FCS占了4字节，所以真正留给上层协议传输数据的大小就是：1518 - 14 - 4 = 1500。

- 1518这个值是考虑到传输效率以及传输时间而折中选择的一个值，并且由于目前网络链路中的节点太多，其中某个节点的MTU值如果和别的节点不一样，就很容易带来拆包重组的问题，甚至会导致无法发送。

- 数据包的名称，数据链路层叫Frame，IP层叫Packet，TCP/UDP叫Segment。

- MSS: Maximum Segment Size。TCP的MSS在握手阶段通过SYN或SYN/ACK数据报文协商，如果一方不接受另一方的MSS值，TCP/IP协议栈会选择使用默认值：536字节。(RFC 791规定任何设备支持的MTU最小为576，实际上576是拨号网络的MTU，而576减去TCP和IP的头就是536)

- MSL: Maxinum Segment Lifetime，目前为2分钟。

- IDC: Internet Data Center。

- RTT: Round Trip Time，一个数据包从发出去到回来的时间。

- RTO: Retransmission Timeout。

- UDP包头8个字节。

  

## TCP

### 拥塞控制

根据[end-to-end准则](https://en.wikipedia.org/wiki/End-to-end_principle)，拥塞控制主要是主机的责任，而不是网络本身。



### 参考资源

- https://en.wikipedia.org/wiki/TCP_congestion_control

## 网络协议设计

### 参考资源

- [APP与后台通信数据格式的演进：从文本协议到二进制协议](https://blog.csdn.net/humn_chou/article/details/80036834)



## 问题

*什么是MTU？为什么MTU值普遍都是1500？*

Maximum Transmission Unit，缩写MTU，中文名是：最大传输单元。在OSI七层模型中，属于数据链路层，限制的是数据链路层的payload，也就是上层协议的大小，例如IP，ICMP等。

MTU其实就是在每一个节点的管控值，只要是大于这个值的数据帧，要么选择分片，要么直接丢弃。

一个标准的以太网数据帧大小是：`1518`，头信息有14字节，尾部校验和FCS（Frame Check Sequence）占了4字节，所以真正留给上层协议传输数据的大小就是：1518 - 14 - 4 = 1500。

因为以太网帧是传输中的最小可识别单元，再往下就是0101所对应的光信号了，所以我们的一条带宽同时只能发送一个以太网帧。如果同时发送多个，那么对端就无法重组成一个以太网帧了。如果MTU值太大，单个数据包的传输时间就会很长，导致其它进程被阻塞；如果MTU值太小，由于包头等固定开销，传输效率会很低。

1518这个值是考虑到传输效率以及传输时间而折中选择的一个值，并且由于目前网络链路中的节点太多，其中某个节点的MTU值如果和别的节点不一样，就很容易带来拆包重组的问题，甚至会导致无法发送。

https://yq.aliyun.com/articles/222535



## 参考资源

- [TLV](https://en.wikipedia.org/wiki/Type-length-value)
- [即时通讯网-IM开发者社区](http://www.52im.net)

- 身份证原件
- 离职证明原件
- 入职OFFER
- 毕业证和学位证复印件

